<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scatterplot Quick Entry - Mockup</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f5f5f5;
      padding: 20px;
      user-select: none;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      overflow: hidden;
    }

    .header {
      background: #1a73e8;
      color: white;
      padding: 16px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .header h1 {
      font-size: 18px;
      font-weight: 500;
    }

    .submit-btn {
      background: #34a853;
      color: white;
      border: none;
      padding: 10px 24px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
    }

    .submit-btn:hover {
      background: #2d9249;
    }

    .patient-info {
      padding: 16px 20px;
      background: #f8f9fa;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
    }

    .info-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .info-field label {
      font-size: 11px;
      color: #666;
      text-transform: uppercase;
      font-weight: 600;
    }

    .info-field select, .info-field input {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      min-width: 150px;
    }

    .toolbar {
      padding: 12px 20px;
      background: #fff;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
    }

    .brush-label {
      font-size: 13px;
      font-weight: 600;
      color: #333;
    }

    .brush-group {
      display: flex;
      gap: 4px;
    }

    .brush-btn {
      padding: 8px 16px;
      border: 2px solid #ddd;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      background: white;
      transition: all 0.15s;
    }

    .brush-btn.ind {
      color: #1a73e8;
      background: repeating-linear-gradient(-45deg, #e3f2fd 0px, #e3f2fd 2px, #fff 2px, #fff 4px);
    }

    .brush-btn.ind.active, .brush-btn.ind:hover {
      background: repeating-linear-gradient(-45deg, #1a73e8 0px, #1a73e8 2px, #64b5f6 2px, #64b5f6 4px);
      border-color: #1a73e8;
      color: white;
    }

    .brush-btn.err {
      color: #333;
    }

    .brush-btn.err.active, .brush-btn.err:hover {
      background: #e0e0e0;
      border-color: #333;
      color: #333;
    }

    .brush-btn.skip {
      color: #e53935;
    }

    .brush-btn.skip.active, .brush-btn.skip:hover {
      background: #ffebee;
      border-color: #e53935;
      color: #c62828;
    }

    .brush-btn.clear {
      color: #666;
    }

    .brush-btn.clear:hover {
      background: #f5f5f5;
    }

    .selection-info {
      margin-left: auto;
      font-size: 13px;
      color: #666;
    }

    .shortcuts {
      font-size: 11px;
      color: #999;
    }

    .shortcuts kbd {
      background: #f0f0f0;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
    }

    .grid-container {
      padding: 16px 20px;
      overflow-x: auto;
    }

    .grid-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .grid-table th {
      background: #f8f9fa;
      padding: 10px 8px;
      text-align: center;
      font-weight: 600;
      border: 1px solid #e0e0e0;
      position: sticky;
      top: 0;
    }

    .grid-table th.time-header {
      text-align: left;
      min-width: 100px;
    }

    .grid-table th.check-header {
      width: 36px;
      min-width: 36px;
      max-width: 36px;
    }

    .grid-table th.behavior-header {
      min-width: 100px;
    }

    .check-cell {
      width: 36px;
      min-width: 36px;
      max-width: 36px;
      cursor: pointer;
      font-size: 14px;
    }

    .check-cell.checked {
      background: #f5f5f5;
      color: #333;
    }

    .check-cell.skipped {
      background: #fff5f5;
      color: #e53935;
    }

    .grid-table td {
      border: 1px solid #e0e0e0;
      padding: 0;
      text-align: center;
    }

    .grid-table td.time-cell {
      padding: 6px 8px;
      text-align: left;
      background: #fafafa;
      font-weight: 500;
      font-size: 11px;
      color: #555;
    }

    .data-cell {
      width: 100%;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.1s;
      font-weight: 600;
      font-size: 11px;
    }

    .data-cell:hover {
      opacity: 0.8;
    }

    .data-cell.empty {
      background: #fff;
      color: #ccc;
    }

    .data-cell.ind {
      background-color: #e8e8e8;
      background-image: url("data:image/svg+xml,%3Csvg width='20' height='20' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 3 Q5 0 10 3 T20 3 M0 8 Q5 5 10 8 T20 8 M0 13 Q5 10 10 13 T20 13 M0 18 Q5 15 10 18 T20 18' stroke='%23666' stroke-width='1.5' fill='none'/%3E%3C/svg%3E");
      background-size: 20px 20px;
    }

    .data-cell.err {
      background: #fff;
      color: #333;
      font-size: 16px;
    }

    .data-cell.skip {
      background: #fff5f5;
      color: #e53935;
      font-size: 14px;
      font-weight: bold;
    }

    .data-cell.selecting {
      outline: 2px solid #1a73e8;
      outline-offset: -2px;
    }

    .totals-row td {
      background: #f0f4f8;
      padding: 8px;
      font-weight: 600;
      font-size: 11px;
    }

    .totals-row .observed {
      color: #1a73e8;
    }

    .footer {
      padding: 16px 20px;
      background: #f8f9fa;
      border-top: 1px solid #e0e0e0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .footer-stats {
      font-size: 13px;
      color: #666;
    }

    .footer-actions {
      display: flex;
      gap: 8px;
    }

    .action-btn {
      padding: 8px 16px;
      border: 1px solid #ddd;
      border-radius: 6px;
      background: white;
      font-size: 13px;
      cursor: pointer;
    }

    .action-btn:hover {
      background: #f5f5f5;
    }

    .action-btn.primary {
      background: #1a73e8;
      color: white;
      border-color: #1a73e8;
    }

    .action-btn.primary:hover {
      background: #1557b0;
    }

    .instructions {
      padding: 16px 20px;
      background: #fffde7;
      border-bottom: 1px solid #fff59d;
      font-size: 13px;
      color: #555;
    }

    .instructions strong {
      color: #333;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Scatterplot Quick Entry</h1>
      <button class="submit-btn" onclick="submitData()">Submit to CR ▶</button>
    </div>

    <div class="patient-info">
      <div class="info-field">
        <label>Client</label>
        <select id="clientSelect">
          <option>John Doe</option>
          <option>Jane Smith</option>
          <option>Alex Johnson</option>
        </select>
      </div>
      <div class="info-field">
        <label>Date</label>
        <input type="date" id="dateInput" value="2026-01-27">
      </div>
    </div>

    <div class="instructions">
      <strong>How to use:</strong>
      <strong>✓ Check</strong> = observed, no behavior (fills row) |
      <strong>Shaded</strong> = behavior occurred (this cell, others become ✓) |
      <strong style="color:#e53935;">✗ Skip</strong> = not observed (fills row).
      Click+drag to fill. Keys: <kbd>I</kbd> <kbd>E</kbd> <kbd>S</kbd> <kbd>C</kbd>
    </div>

    <div class="toolbar">
      <span class="brush-label">Brush:</span>
      <div class="brush-group">
        <button class="brush-btn ind active" data-brush="ind" onclick="setBrush('ind')" title="Behavior occurred (this cell only)">Shaded</button>
        <button class="brush-btn err" data-brush="err" onclick="setBrush('err')" title="Observed, no behavior (fills row)">✓ Check (row)</button>
        <button class="brush-btn skip" data-brush="skip" onclick="setBrush('skip')" title="Not observed (fills row)">✗ Skip (row)</button>
        <button class="brush-btn clear" data-brush="empty" onclick="setBrush('empty')" title="Clear cell">Clear</button>
      </div>
      <span style="border-left: 1px solid #ddd; height: 24px; margin: 0 8px;"></span>
      <button class="action-btn" onclick="fillAllERR()" style="background:#f0f0f0;color:#333;padding:8px 12px;font-size:12px;">Fill All ✓</button>
      <button class="action-btn" onclick="fillAllSkip()" style="background:#ffebee;color:#c62828;padding:8px 12px;font-size:12px;">Fill All ✗</button>
      <span class="selection-info" id="selectionInfo" style="margin-left:auto;">Click and drag to fill cells</span>
    </div>

    <div class="grid-container">
      <table class="grid-table" id="gridTable">
        <thead>
          <tr>
            <th class="time-header">Time</th>
            <th class="check-header">✓</th>
            <th class="behavior-header">Aggression</th>
            <th class="behavior-header">Elopement</th>
            <th class="behavior-header">SIB</th>
            <th class="behavior-header">Screaming</th>
          </tr>
        </thead>
        <tbody id="gridBody">
          <!-- Generated by JS -->
        </tbody>
        <tfoot>
          <tr class="totals-row">
            <td><strong>Observed</strong></td>
            <td class="observed" id="obs-0">0/96</td>
            <td class="observed" id="obs-1">0/96</td>
            <td class="observed" id="obs-2">0/96</td>
            <td class="observed" id="obs-3">0/96</td>
          </tr>
          <tr class="totals-row">
            <td><strong>IND count</strong></td>
            <td id="ind-0">0</td>
            <td id="ind-1">0</td>
            <td id="ind-2">0</td>
            <td id="ind-3">0</td>
          </tr>
          <tr class="totals-row">
            <td><strong>ERR count</strong></td>
            <td id="err-0">0</td>
            <td id="err-1">0</td>
            <td id="err-2">0</td>
            <td id="err-3">0</td>
          </tr>
        </tfoot>
      </table>
    </div>

    <div class="footer">
      <div class="footer-stats">
        Total cells filled: <span id="totalFilled">0</span> / 384
      </div>
      <div class="footer-actions">
        <button class="action-btn" onclick="clearAll()">Clear All</button>
        <button class="action-btn primary" onclick="copyForCR()">Copy for CR</button>
      </div>
    </div>
  </div>

  <script>
    const behaviors = ['Aggression', 'Elopement', 'SIB', 'Screaming'];
    const numBehaviors = behaviors.length;
    const numIntervals = 96;

    // Data storage: grid[row][col] = 'empty' | 'ind' | 'err' | 'skip'
    let grid = [];
    let currentBrush = 'ind';
    let isMouseDown = false;
    let startCell = null;

    // Initialize grid
    function initGrid() {
      grid = [];
      for (let i = 0; i < numIntervals; i++) {
        grid[i] = [];
        for (let j = 0; j < numBehaviors; j++) {
          grid[i][j] = 'empty';
        }
      }
    }

    // Format time for display
    function formatTime(intervalIndex) {
      const totalMinutes = 7 * 60 + intervalIndex * 15; // Start at 7:00 AM
      const hours = Math.floor(totalMinutes / 60) % 24;
      const minutes = totalMinutes % 60;
      const period = hours >= 12 ? 'PM' : 'AM';
      const displayHour = hours % 12 || 12;
      const startTime = `${displayHour}:${String(minutes).padStart(2, '0')}`;

      const endMinutes = totalMinutes + 14;
      const endHours = Math.floor(endMinutes / 60) % 24;
      const endMins = endMinutes % 60;
      const endPeriod = endHours >= 12 ? 'PM' : 'AM';
      const endDisplayHour = endHours % 12 || 12;
      const endTime = `${endDisplayHour}:${String(endMins).padStart(2, '0')}`;

      return `${startTime}-${endTime} ${period}`;
    }

    // Track row status: 'empty' | 'checked' | 'skipped'
    let rowStatus = [];

    function initRowStatus() {
      rowStatus = [];
      for (let i = 0; i < numIntervals; i++) {
        rowStatus[i] = 'empty';
      }
    }

    // Build the grid HTML
    function buildGrid() {
      const tbody = document.getElementById('gridBody');
      tbody.innerHTML = '';

      for (let row = 0; row < numIntervals; row++) {
        const tr = document.createElement('tr');

        // Time cell
        const timeCell = document.createElement('td');
        timeCell.className = 'time-cell';
        timeCell.textContent = formatTime(row);
        tr.appendChild(timeCell);

        // Check column cell
        const checkTd = document.createElement('td');
        const checkCell = document.createElement('div');
        checkCell.className = 'data-cell check-cell';
        checkCell.dataset.row = row;
        checkCell.dataset.type = 'check';
        checkCell.addEventListener('mousedown', handleCheckClick);
        checkCell.addEventListener('mouseenter', handleCheckDrag);
        checkTd.appendChild(checkCell);
        tr.appendChild(checkTd);

        // Behavior data cells
        for (let col = 0; col < numBehaviors; col++) {
          const td = document.createElement('td');
          const cell = document.createElement('div');
          cell.className = 'data-cell empty';
          cell.dataset.row = row;
          cell.dataset.col = col;

          cell.addEventListener('mousedown', handleMouseDown);
          cell.addEventListener('mouseenter', handleMouseEnter);
          cell.addEventListener('mouseup', handleMouseUp);

          td.appendChild(cell);
          tr.appendChild(td);
        }

        tbody.appendChild(tr);
      }
    }

    // Handle click on check column
    function handleCheckClick(e) {
      isMouseDown = true;
      const row = parseInt(e.target.dataset.row);
      toggleRowCheck(row);
      e.preventDefault();
    }

    // Handle drag on check column
    function handleCheckDrag(e) {
      if (isMouseDown) {
        const row = parseInt(e.target.dataset.row);
        // Apply same status as the first clicked row
        if (rowStatus[row] !== rowStatus[startCheckRow]) {
          toggleRowCheck(row);
        }
      }
    }

    let startCheckRow = null;

    // Cycle check column: empty → ✓ → ✗ → empty
    function toggleRowCheck(row) {
      if (startCheckRow === null) startCheckRow = row;

      // If row has any IND, don't allow check column changes
      if (hasAnyIND(row)) return;

      if (rowStatus[row] === 'empty') {
        // Empty → Checked (all ERR)
        rowStatus[row] = 'checked';
        for (let col = 0; col < numBehaviors; col++) {
          grid[row][col] = 'err';
        }
      } else if (rowStatus[row] === 'checked') {
        // Checked → Skipped (all skip)
        rowStatus[row] = 'skipped';
        for (let col = 0; col < numBehaviors; col++) {
          grid[row][col] = 'skip';
        }
      } else {
        // Skipped → Empty
        rowStatus[row] = 'empty';
        for (let col = 0; col < numBehaviors; col++) {
          grid[row][col] = 'empty';
        }
      }
      updateRowDisplayNew(row);
      updateTotals();
    }

    // Handle mouse events for click+drag
    function handleMouseDown(e) {
      isMouseDown = true;
      startCell = { row: parseInt(e.target.dataset.row), col: parseInt(e.target.dataset.col) };
      applyBrush(e.target);
      e.preventDefault();
    }

    function handleMouseEnter(e) {
      if (isMouseDown) {
        applyBrush(e.target);
      }
    }

    function handleMouseUp(e) {
      isMouseDown = false;
      startCell = null;
    }

    // Apply current brush to a cell
    function applyBrush(cell) {
      const row = parseInt(cell.dataset.row);
      const col = parseInt(cell.dataset.col);

      if (currentBrush === 'err') {
        // ERR = observed entire interval, no behaviors → check the row
        rowStatus[row] = 'checked';
        for (let c = 0; c < numBehaviors; c++) {
          grid[row][c] = 'err';
        }
        updateRowDisplayNew(row);
      } else if (currentBrush === 'skip') {
        // Skip = not observed → fill entire row with skip
        rowStatus[row] = 'skipped';
        for (let c = 0; c < numBehaviors; c++) {
          grid[row][c] = 'skip';
        }
        updateRowDisplayNew(row);
      } else if (currentBrush === 'ind') {
        // IND = this specific behavior occurred
        if (grid[row][col] === 'ind') {
          // Already shaded - toggle it off (back to ERR since row was observed)
          grid[row][col] = 'err';
        } else {
          // Mark this cell as IND
          grid[row][col] = 'ind';
          // Row is now checked (observed) with this behavior
          rowStatus[row] = 'checked';
          // Other cells in row that are empty or skip should become ERR (you were observing)
          for (let c = 0; c < numBehaviors; c++) {
            if (c !== col && (grid[row][c] === 'empty' || grid[row][c] === 'skip')) {
              grid[row][c] = 'err';
            }
          }
        }
        updateRowDisplayNew(row);
      } else {
        // Clear - clear this cell and possibly row status
        grid[row][col] = 'empty';
        // Check if entire row is now empty
        let allEmpty = true;
        for (let c = 0; c < numBehaviors; c++) {
          if (grid[row][c] !== 'empty') allEmpty = false;
        }
        if (allEmpty) rowStatus[row] = 'empty';
        updateRowDisplayNew(row);
      }

      updateTotals();
    }

    // Update all cells in a row (old version for compatibility)
    function updateRowDisplay(row) {
      updateRowDisplayNew(row);
    }

    // Update row display with check column logic
    function updateRowDisplayNew(row) {
      const checkCell = document.querySelector(`.check-cell[data-row="${row}"]`);
      const status = rowStatus[row];
      const hasIND = hasAnyIND(row);

      // Update check column - blank if row has any shaded behaviors
      if (checkCell) {
        checkCell.className = 'data-cell check-cell';
        if (hasIND) {
          // Row has shaded behaviors - check column is blank
          checkCell.textContent = '';
        } else if (status === 'checked') {
          checkCell.classList.add('checked');
          checkCell.textContent = '✓';
        } else if (status === 'skipped') {
          checkCell.classList.add('skipped');
          checkCell.textContent = '✗';
        } else {
          checkCell.textContent = '';
        }
      }

      // Update behavior cells
      for (let col = 0; col < numBehaviors; col++) {
        const cell = document.querySelector(`.data-cell[data-row="${row}"][data-col="${col}"]`);
        if (cell) {
          const val = grid[row][col];

          if (status === 'skipped' || val === 'skip') {
            // Skipped row - show red X
            cell.className = 'data-cell skip';
            cell.textContent = '✗';
          } else if (val === 'ind') {
            // IND - show shaded pattern only
            cell.className = 'data-cell ind';
            cell.textContent = '';
          } else if (status === 'checked' || val === 'err') {
            // Checked row with no IND - show blank (but data is ERR)
            cell.className = 'data-cell empty';
            cell.textContent = '';
          } else {
            // Empty
            cell.className = 'data-cell empty';
            cell.textContent = '';
          }
        }
      }
    }

    // Check if row has any IND values
    function hasAnyIND(row) {
      for (let col = 0; col < numBehaviors; col++) {
        if (grid[row][col] === 'ind') return true;
      }
      return false;
    }

    // Update cell visual
    function updateCellDisplay(cell, value) {
      cell.className = 'data-cell ' + value;
      switch (value) {
        case 'ind':
          cell.textContent = '';  // Shaded pattern only, no text
          break;
        case 'err':
          cell.textContent = '✓';  // Check mark
          break;
        case 'skip':
          cell.textContent = '✗';   // Red X for skipped
          break;
        default:
          cell.textContent = '';   // Empty (unfilled)
      }
    }

    // Set brush
    function setBrush(brush) {
      currentBrush = brush;
      document.querySelectorAll('.brush-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.brush === brush);
      });
    }

    // Update totals
    function updateTotals() {
      let totalFilled = 0;

      for (let col = 0; col < numBehaviors; col++) {
        let observed = 0;
        let indCount = 0;
        let errCount = 0;

        for (let row = 0; row < numIntervals; row++) {
          const val = grid[row][col];
          if (val !== 'empty') {
            totalFilled++;
          }
          if (val === 'ind' || val === 'err') {
            observed++;
          }
          if (val === 'ind') indCount++;
          if (val === 'err') errCount++;
        }

        document.getElementById(`obs-${col}`).textContent = `${observed}/${numIntervals}`;
        document.getElementById(`ind-${col}`).textContent = indCount;
        document.getElementById(`err-${col}`).textContent = errCount;
      }

      document.getElementById('totalFilled').textContent = totalFilled;
    }

    // Clear all
    function clearAll() {
      if (confirm('Clear all data?')) {
        initGrid();
        initRowStatus();
        rebuildAllRows();
        updateTotals();
      }
    }

    // Fill entire grid with ERR (all rows checked)
    function fillAllERR() {
      for (let row = 0; row < numIntervals; row++) {
        rowStatus[row] = 'checked';
        for (let col = 0; col < numBehaviors; col++) {
          grid[row][col] = 'err';
        }
      }
      rebuildAllRows();
      updateTotals();
    }

    // Fill entire grid with Skip
    function fillAllSkip() {
      for (let row = 0; row < numIntervals; row++) {
        rowStatus[row] = 'skipped';
        for (let col = 0; col < numBehaviors; col++) {
          grid[row][col] = 'skip';
        }
      }
      rebuildAllRows();
      updateTotals();
    }

    // Rebuild all row displays
    function rebuildAllRows() {
      for (let row = 0; row < numIntervals; row++) {
        updateRowDisplayNew(row);
      }
    }

    // Rebuild all cell displays from grid data
    function rebuildCellDisplays() {
      document.querySelectorAll('.data-cell').forEach(cell => {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);
        updateCellDisplay(cell, grid[row][col]);
      });
    }

    // Copy formatted data for CR
    function copyForCR() {
      let output = `Scatterplot Data - ${document.getElementById('clientSelect').value}\n`;
      output += `Date: ${document.getElementById('dateInput').value}\n\n`;

      for (let col = 0; col < numBehaviors; col++) {
        output += `=== ${behaviors[col]} ===\n`;
        let observed = 0;
        let entries = [];

        for (let row = 0; row < numIntervals; row++) {
          let val = grid[row][col];
          // Treat empty as skip (blank = not observed)
          if (val === 'empty') val = 'skip';

          const time = formatTime(row);
          if (val === 'ind') {
            entries.push(`${time}: IND`);
            observed++;
          } else if (val === 'err') {
            entries.push(`${time}: ERR`);
            observed++;
          } else if (val === 'skip') {
            entries.push(`${time}: >`);
          }
        }

        output += `Intervals observed: ${observed}/${numIntervals}\n`;
        output += entries.join('\n') + '\n\n';
      }

      navigator.clipboard.writeText(output).then(() => {
        alert('Data copied to clipboard!');
      });
    }

    // Submit to CR (placeholder)
    function submitData() {
      alert('Submit to CR functionality will be available once API credentials are configured.\n\nFor now, use "Copy for CR" to copy the data.');
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      switch (e.key.toLowerCase()) {
        case 'i':
          setBrush('ind');
          break;
        case 'e':
          setBrush('err');
          break;
        case 's':
          setBrush('skip');
          break;
        case 'c':
          setBrush('empty');
          break;
      }
    });

    // Prevent text selection during drag
    document.addEventListener('mouseup', () => {
      isMouseDown = false;
      startCheckRow = null;
    });

    // Initialize
    initGrid();
    initRowStatus();
    buildGrid();
  </script>
</body>
</html>
